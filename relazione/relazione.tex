\documentclass[]{article}
\usepackage[a4paper, total={6.5in, 10.5in}]{geometry}%6
\usepackage[ruled,vlined,linesnumbered]{algorithm2e}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{longtable}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{float}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
	backgroundcolor=\color{backcolour},   
	commentstyle=\color{codegreen},
	keywordstyle=\color{magenta},
	numberstyle=\tiny\color{codegray},
	stringstyle=\color{codepurple},
	basicstyle=\ttfamily\footnotesize,
	breakatwhitespace=false,         
	breaklines=true,                 
	captionpos=b,                    
	keepspaces=true,                 
	numbers=left,                    
	numbersep=5pt,                  
	showspaces=false,                
	showstringspaces=false,
	showtabs=false,                  
	tabsize=2,
	frame=single
}

% Title Page
\title{Homework2, Algoritmi su Grafi}
\author{Enrico Cancelli, \textit{matr.} 1237293\\
	Alessandro Pegoraro, \textit{matr.} 1240466}

\begin{document}

\maketitle

\begin{abstract}

\end{abstract}

\section{Introduzione}
Lo scopo di questo  progetto è l'analisi e l'implementazione di algoritmi per la risoluzione del problema del \textit{Traveling Salesman} (in seguito TSP) su grafi completi i cui archi hanno pesi che rispettano la disuguaglianza triangolare (anche detto \textit{Triangle-TSP}).
Gli algoritmi implementati sono:
\begin{enumerate}
	\item Algoritmo (esatto) di Held e Karp
	\item Algoritmo (approssimato) di 2-approssimazione basato su MST
	\item Algoritmo (approssimato) basato su euristica costruttiva \textit{cheapest-insertion}
\end{enumerate}
\subsection{Pseudocodice}
Come riferimento per l'implementazione di questi algoritmi è stato utilizzato il seguente pseudocodice spiegato durante le lezioni di laboratorio:\\
\begin{algorithm}[H]
	\SetAlgoLined
	\DontPrintSemicolon
	\KwIn{Graph G = (V,E), S $\subseteq$ V, vertex v $\in$ S}
	\KwResult{Minimum Weight of complete path in S from 0 to v }
	\SetKwFunction{VISIT}{HK-VISIT}
	\SetKwProg{Fn}{function}{}{}
  	\Fn{\VISIT{v,S}}{
        \uIf{S = \{v\}}{
			\textbf{return} w[v,0]\;
		}
		\uElseIf{d[v,S] $\neq$ NULL}{
			\textbf{return} d[v,S]\;
		}
		\Else{
			mindist = +$\infty$\;
			minprec = NULL\;
			\For{each u $\in$ S \textbackslash \{v\}}{
				dist = HK-VISIT(u, S\textbackslash \{v\})\;
				\If{dist + w[u,v] $<$ mindist}{
					mindist = dist + w[u,v]\;
					minprec = u\;
				}
			}
			d[v,S] = mindist\;
			$\pi$[v,S] = minprec\;	
			\textbf{return} mindist\;	
		}
  	}
  	\textbf{end function}\;
	\caption{Held e Karp}
\end{algorithm}
\begin{algorithm}[H]
	\SetAlgoLined
	\DontPrintSemicolon
	\KwResult{Hamiltonial cycle}
	\SetKwFunction{VISIT}{HK-TSP}
	\SetKwProg{Fn}{function}{}{}
  	\Fn{\VISIT{G}}{
  		\textbf{let} G = (V,E)\;
  		d = Ø\;
		$\pi$ = Ø\;	
		\textbf{return} HK-VISIT(0,V)\;		
  	}
  	\textbf{end function}\;
	\caption{Initialization and call to HK-VISIT}
\end{algorithm}
\begin{algorithm}[H]
	\SetAlgoLined
	\DontPrintSemicolon
	\KwIn{Vertex v}
	\KwResult{Preorder list of MST}
	\SetKwFunction{PRE}{PREORDER}
	\SetKwProg{Fn}{function}{}{}
  	\Fn{\PRE{v}}{
  		P.add(v)\tcp*{Add v to the preorder list of MST P}
        \uIf{internal(v)}{
			\For{each u $\in$ children(v)}{
				\textbf{PREORDER}(u)\;
			}
		}
		\textbf{return} P
  	}
  	\textbf{end function}\;
	\caption{Preorder for 2-approximation}
\end{algorithm}
\begin{algorithm}[H]
	\SetAlgoLined
	\DontPrintSemicolon
	\KwIn{Graph G = (V,E), cost function c}
	\KwResult{Hamiltonial cycle}
	\SetKwFunction{APP}{APPROX\_T\_TSP}
	\SetKwProg{Fn}{function}{}{}
  	\Fn{\APP{G,c}}{
  		V = \{$v_i1$, $v_i2$, $\cdots$, $v_in$\}\;
  		r $\gets$ v1 \tcp*{Starting radix for Prim}
  		T* $\gets$ \textbf{PRIM}(G,c,r)\;
  		$<v_i1$, $v_i2$, $\cdots$, $v_in>$ = $H^\prime$ $\gets$ \textbf{PREORDER}(r)\;
		\textbf{return} $<H^\prime$, $v_in>$ = $H$\;
  	}
  	\textbf{end function}\;
	\caption{2-approximation}
\end{algorithm}
\begin{algorithm}[H]
	\SetAlgoLined
	\DontPrintSemicolon
	\KwIn{Graph G = (V,E)}
	\KwResult{Hamiltonial cycle}
	mindist = +$\infty$\; 
	j = NULL \tcp*{Find j who minimize w(0,j)}
	\For{each u $\in$ V  \textbackslash \{0\}}{
			\If{w(0,u) $<$ mindist}{
				mindist = w(0,u)\;
				j = u\;
			}
	}
	C = \{0, j, 0\}\tcp*{Repeat until the circuit has all the vertices}
	\While{$|$C $|$ $<$ $|$V $|$ + 1}{
		mindist = +$\infty$\;
		find\_i = NULL\;
		find\_j = NULL\;
		find\_k = NULL\;
		\For{each (i,j) adjacent in C}{
			\For{each k $\in$ V  \textbackslash C}{
				\If{w(i,k) + w(k,j) - w(i,j) $<$ mindist}{
					mindist = w(i,k) + w(k,j) - w(i,j)\;
					find\_i = i\;
					find\_j = j\;
					find\_k = k\;
				}		
			}
		}
	C.insertBetween(find\_i, find\_j, find\_k)\tcp*{Insert k in C between i and j}
	}
	\textbf{return} C\;
	\caption{Cheapest-Insertion}
\end{algorithm}
\section{Implementazione}
In questa sezione verranno esposte e adeguatamente motivate le scelte implementative adottate durante lo sviluppo. L'intero progetto è stato realizzato facendo il più possibile uso di codice generico (template di classe per le strutture dati di supporto e template di funzione per gli algoritmi).\\
Infine verrà data una spiegazione dettagliata sulla struttura del codice realizzato ed eventuali note per la compilazione.
\subsection{Parser}
Il dataset fornito è costituito, come per il progetto precedente, da un file per ogni grafo.\\
La struttura dei file è espressa dalla seguente formula BNF:
\begin{verbatim}
<file> :: = <name-dec>
            <type-comment block>
            <dimension>
            <edge-t-dec>
            <edge-f-dec>?
            <display-dec>?
            <coord-sec>
            EOF
<name-dec> :: = NAME: <word> \n
<type-comment block> :: = <type-dec> <comment> | 
                          <comment> <type-dec>
<type-dec> :: = TYPE: TSP \n
<comment> :: = COMMENT: <phrase> \n
<dimension> :: = DIMENSION: <integer> \n
<edge-t-dec> :: = EDGE_WEIGHT_TYPE: <edge-type> \n
<edge-type> :: = GEO | EUC_2D
<edge-f-dec> :: = EDGE_WEIGHT_FORMAT: FUNCTION \n
<display-dec> :: = DISPLAY_DATA_TYPE: COORD_DISPLAY \n
<coord-sec> :: = NODE_COORD_SECTION \n
                 <coordinates>
<coordinates> :: = <coordinate> \n
                   <coordinates> |
                   <coordinate> \n
<coordinate> :: = <integer> <float> <float>
\end{verbatim}
La classe \textit{Parser} si occupa della decodifica di questi file e organizza le informazioni rilevanti quali tipologia delle coordinate, dimensione e coordinate dei nodi creando un oggetto di classe \textit{Graph\_data}.
\subsection{Strutture dati generiche}
\subsubsection{Matrix}
La classe \textit{Matrix$<$T$>$} rappresenta una generica matrice rettangolare di oggetti di tipo T.\\
Essa è utilizzata per la memorizzazione della matrice di adiacenza associata a un grafo.
\subsubsection{MinHeap}
La struttura dati \textit{MinHeap} è la stessa utilizzata nel progetto precedente ed è utilizzata per l'esecuzione dell'algoritmo di Prim all'interno dell'algoritmo di 2-approssimazione.
\subsection{Strutture per la rappresentazione di grafi e sottoinsiemi di nodi}
\subsubsection{Graph\_Data}
Per rappresentare i dati estratti da un file relativo ad un certo grafo, abbiamo usato il template di classe \textit{Graph\_data$<$T$>$}. Gli oggetti di questo tipo contengono i seguenti campi dati:
\begin{itemize}
	\item Nome del grafo
	\item Tipo di coordinate (\verb|cartesian| o \verb|geo|)
	\item Dimensione del grafo (numero di nodi)
	\item Lista di coordinate (rappresentata come un vettore di coppie di elementi di tipo T)
\end{itemize}
Questa classe espone un unico metodo \verb|get_weights| che restituisce la matrice di adiacenza associata al grafo rappresentato dall'oggetto su cui viene invocato. La costruzione di tale matrice dipende dalla tipologia di coordinate.\\
Generalmente la matrice di adiacenza è espressa dalla seguente formula:
$$w[i,j]=dist\_fun(i, j)$$
Dove \verb|dist_fun(i,j)| è la distanza tra il nodo $i$ e $j$ del grafo.\\
In caso le coordinate di un nodo siano di tipo cartesiano, \verb|dist_fun| è la distanza euclidea:
$$dist\_fun(i,j)=round(\sqrt{((i.x - j.x)^2 + (i.y - j.y)^2)})$$
In caso le coordinate di un nodo siano coordinate geografiche, \verb|dist_fun| è la seguente funzione:
$$**formula**$$
\subsubsection{SubSet}

\subsection{Algoritmi}
\subsubsection{Prim}
\subsubsection{Held e Karp}
\subsubsection{2-approssimazione}
\subsubsection{Euristica cheapest-insertion}

\section{Analisi}
%TODO la tabella esce dai margini
\input{tabella_richiesta.tex}

\end{document}
